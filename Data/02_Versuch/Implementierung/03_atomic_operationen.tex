\subsection{Atomic Operationen} \label{atomic}

Da nun bekannt ist, was eine \textit{Dual}-Zahl ist, 
kann das eigentliche Problem betrachtet werden.
Die Implementierung der \textit{scatter!} Funktion benutzt folgenden Programmcode, um die 
Addition umzusetzen.

\begin{verbatim}
    	CUDA.@atomic dst[idx[index]...] = op(dst[idx[index]...], src[index])
\end{verbatim}


Dabei ist der Macro \textit{@atomic} ein Wrapper um die C-Implementierung von \textit{CUDA.jl} \cite{besard2018juliagpu}.
Das Probelem das auftritt ist, dass der Macro nur die Datentypen \{Float16, Float32, Float64, BFloat16 \}
unterstützt.
Es ist möglich, die unterstützten Datentypen zu erweitern.
Voraussetzung dafür ist, dass der neue Datentype kleiner gleich 64-Bit ist.
Da eine \textit{Dual} Zahl nur für $k = 1$ und Datentype \textit{Float32} genau 64-Bit groß ist,
kann nur in besonderen fällen \textit{@atomic} direkt verwendet werden.
Da dieser Sonderfall meistens nicht auftritt, ist dieser Ansatz unbrauchbar.
Der \textit{@atomic} Aufruf wird benötigt,
um \textit{Read-Modify-Write} Operationen zu serialisieren, 
und um \textit{Race-Conditions} zu vermeiden. 
Deshalb kann dieser auch nicht weggelassen werden.
Aus der Definition der multidimensionalen \textit{Dual}-Zahlen 
ist bekannt, das \textit{Dual}-Zahlen Komponenten weiße addiert werden.
Da die einzelnen Komponenten reellen Zahlen 
bzw. in der Praxis \textit{Floats} sind, liegt folgende Implementierung nahe:

\begin{lstlisting}{language=Julia}

function gpu_add!(d0::Dual, d1::Dual, d2::Dual)
	@atomic value(d0) = value(d1) + value(d2)
	k = length(partials(d0)) # length(partials( )) ist fuer alle Argumente Gleich
	for i in 1:k
		@atomic partials(d0, i) = partials(d1, i) + partials(d2, i)
	end
end

\end{lstlisting}

Wird die \textit{scatter} Funktion nun wie beschrieben implementiert, kommt es zu einem weiteren Problem.
Der Macro \textit{@atomic} verbietet die Funktions aufrufe \textit{value} und \textit{partial}.
Dies liegt daran, dass ein Macro in der Julia Sprache Zugang auf den \textit{Abstract Syntax Tree} des Compilers hat
und einen direkten Zugriff auf ein \textit{Array} erwartet.
Der Aufruf der \textit{partial} Funktion führt außerdem skalare Indexierung durch, welche auf der Grafikkarte nicht erlaubt ist.