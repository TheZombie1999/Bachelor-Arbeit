\subsection{Eine Funktionierende Implementierung}

In diesem Kapitel geht es darum, wie die \textit{scatter} Funktion umgesetzt werden kann.
Dazu werden die Argumente der \textit{scatter} Funktion aus Kapitel \ref{Vorstellung} so
umgeformt, 
dass die bereits vorhandenen Implementierungen der \textit{scatter!} Funktion der \textit{NNlibCUDA.jl} Bibliothek 
diese richtig verarbeiten kann.
Dafür wird zuerst \textit{Global Memory} \ref{memory} reserviert. Dann werden Kernels verwenden, 
um die Werte schnell und im richtigen Format in den neuen Speicherbereich zu kopieren.
Als Kernel wird eine Funktion bezeichnet, die auf mehreren Threads von der Grafikkarte ausgeführt wird.
Die ursprünglichen Arrays \textit{src} und \textit{dst} haben die Dimension N.

Das Array \textit{idx} hat entweder Dimension N und enthält Tupel von gleicher Größe
oder Dimension eins und enthält \textit{Interger} Zahlen.

Falls die Dimension von \textit{idx} eins ist und die Dimension von \textit{src}
und \textit{dst} größer, dann wird \textit{idx} Zeilen weiße angewendet.
Es wird nun eine Kopie dieser drei Arrays erstellt mit Dimension N+1.
In der zusätzlichen Dimension werden die einzelnen Komponenten der Dual Zahl gespeichert.
Ein Beispiel mit $N = 1$ für \textit{src} und \textit{dst} sieht wie folgt aus:


\begin{gather}
\text{src oder dst} = 
\begin{bmatrix}
Dual & Dual & Dual\\
\end{bmatrix}\\
\rightarrow\\
\text{src\_m oder dst\_m} = 
\begin{bmatrix}
Value   & Value   & Value   \\
Partial & Partial & Partial \\
Partial & Partial & Partial \\
Partial & Partial & Partial \\
\end{bmatrix}
\end{gather}


Das \textit{idx} Array ist in dieser Hinsicht besonders.
Da die Einzelnen \textit{Integer}-Zahlen zu Tupel um gewandelt werden müssen.

\begin{equation}
\text{idx}= 
\begin{bmatrix}
 2 & 1 & 3
\end{bmatrix}
\rightarrow
\text{idx\_m} = 
\begin{bmatrix}
 (2, 1) & (1, 1) & (3, 1) \\ 
 (2, 2) & (1, 2) & (3, 2) \\
 (2, 3) & (1, 3) & (3, 3) \\
 (2, 4) & (1, 4) & (3, 4) \\
\end{bmatrix}
\end{equation}

Das Erweitern des \textit{idx} Arrays sorgt dafür, das die richtigen Komponenten miteinander verrechnet werden.
Die Anzahl der Zeilen in beiden Beispielen ist abhängig von der Anzahl der Freien Variablen  
der Multidimensionalen \textit{Dual} Zahlen. In diesem Beispiel ist $k = 3$.
Wird nun \textit{dst\_m}, \textit{src\_m} und \textit{idx\_m} an die \textit{scatter!} Funktion über
geben, wird das erwünschte Ergebnis berechnet. 
Im letzten Schritt muss nun der Inhalt von \textit{dst\_m} nach \textit{dst} zurück kopiert werden.
Dabei tritt das Problem auf das die partiellen Komponenten innerhalb der \textit{Dual}-Zahl
als Tupel gespeichert werden.
Tupel in Julia sind unveränderlich, nachdem sie erstellt wurden.
Das Problem dabei ist, dass alle partiellen Komponenten der dual zahl gleichzeitig zugegriffen werden muss.
Dazu muss jede einzelne Komponente Scalar indiziert werden.
Dabei kommt es innerhalb der Julia Implementierung zu inkonsistenten verhalten.
Folgender Speicherzugriff eines bestimmten Kernels funktioniert problemlos:


\begin{verbatim}
    dst\_m[3, 4, 5, 1]
\end{verbatim}
Wird dieser Aufruf leicht modifiziert, um all partiellen Komponenten zu einem Tupel zusammen zu fassen, 
kommt es zu einem Compiler Fehler.
\begin{verbatim}
    ( [dst_m[3, 4, 5, i] for i in 2:k+1]... )
\end{verbatim}
Der Grund führ diesen Fehler ist nicht bekannt, kann aber umgangen werden, indem mehrere \textit{views} auf
\textit{dst\_m} erstellt werden.
Das Verwenden von \textit{views} löst das Problem von skalarer Indizierung innerhalb der Grafikkarten Kernel. 
Eine \textit{view} erlaubt es, die Art und weiße wie auf einen Speicher Bereich zugegriffen wird, zu verändern.
Diese werden auf der CPU erstellt und dann dem Kernel als Argument übergeben.
Um zum Beispiel ein Array von Tupeln mit den \textit{Partials} als Inhalt zu erhalten, wird folgender Code ausgeführt:
\begin{verbatim}
	function f(x...)
		return x
	end
	
	tuples = f.([view(dst_m, repeat([:], 
	        ndims(dst_m) - 1)..., i) for i in 2:(N+1)]...)
\end{verbatim}
In diesem Beispiel wird ein Broadcast Kernel mit der Funktion f aufgerufen.
Broadcasting bedeutet, das diese auf jeder Speicherzellen der Argumente angewandt wird.
Diese Operation läuft auf der Grafikkarte.
Für mehr Details zur genauen Umsetzung kann der Code im Anhang eingesehen werden.