\section{Funktionierende Löser}

In diesem Abschnitt wird ein Überblick darüber gegeben, welche 
ODE-Löser nach dem Hinzufügen der in Kapitel \ref{ch:versuch} vorgestellten 
Version der \textit{scatter}-Funktion nun möglich sind.
Funktional sind alle SDIRK-Methoden, welche eine Sammlung von
\textit{singly-diagonal} Runge-Kutta-Verfahren \cite{sdirk} ist.
Durchgelaufen sind außerdem alle Rosenbrock und Rosenbrock-W Methoden,
außerdem gehen fünf der acht Mehr-Schritt-Methoden (Multi-Step-Methods).
Eine detaillierte Auflistung aller impliziten Löser und ihrem 
funktionalen Stand findet sich im Anhang \ref{solver_tabels}.
Wichtig ist dabei, dass es nicht möglich ist jeden Löser ausführlich zu testen,
da diese zum Teil eine sehr lange Laufzeit haben.
Da das Testen der Algorithmen automatisch durchgeführt wurde,
kann es sein, dass manche Fehler durch eine falsche Konfiguration ausgelöst wurden.
Die Vorgehensweise beim Testen war, dass jeder im Anhang als funktionierend 
bezeichneten Löser, so lange ausgeführt wurde, bis dieser den ersten Zeitschritt erfolgreich berechnet hat.
Der Grund für diese Vorgehensweise ist, dass die Löser an diesem Punkt meistens scheitern,
wenn dieser Punkt überschritten ist, dann kam es erfahrungsgemäß zu keinen 
weiteren Problemen, eine 100\%-tige Garantie liefert dies aber nicht.
Ausführlich getestet wurden alle Algorithmen, die in Kapitel \ref{ch:auswertung} vorgestellt wurden.
Es sind nicht alle Gründe bekannt, warum manche Löser noch nicht funktionieren.
Bekannte Probleme sind allerdings:

\begin{itemize}
    \item Multithreading
    \item Asynchrone Ausführung
    \item Komplexe Zahlen
    \item Skalare Indexierung
    \item Invalides Casting
\end{itemize}

Laut der \textit{CUDA} Dokumentation sollte Multithreading und Asynchrone Ausführung funktionieren.
In unseren Tests hat sich das jedoch nie bestätigt.
Die \textit{scatter}-Funktion kann aktuelle nur \textit{Dual}-Zaheln, die reelle Zahlen enthalten verwenden. Theoretisch könnten mache Löser allerdings auch komplexe Zahlen verwenden.
Dies ist aktuell nicht unterstützt,
könnte aber relativ leicht mit einem ähnlichen Ansatz wie in Kapitel \ref{ch:versuch} vorgestellt wurde, gelöst werden.




% \begin{table}[]
%     \centering
    
%     \begin{tabular}{p{5cm}|c|p{5cm}}
%         Name             & Funktionale & Fehler \\
%         \hline\hline        
%         ImplicitEuler    & true        & \\ 
%         ImplicitMidpoint & true        & \\ 
%         Trapezoid        & true        & \\ 
%         TRBDF2           & true        & \\ 
%         SDIRK2           & true        & \\ 
%         Kvaerno3         & true        & \\ 
%         KenCarp3         & true        & \\ 
%         Cash4            & true        & \\ 
%         Hairer4          & true        & \\ 
%         Hairer42         & true        & \\ 
%         Kvaerno4         & true        & \\ 
%         KenCarp4         & true        & \\ 
%         KenCarp47        & true        & \\ 
%         Kvaerno5         & true        & \\ 
%         KenCarp5         & true        & \\ 
%         KenCarp58        & true        & \\       
%     \end{tabular}
%     \caption{SDIRK Methods}
%     \label{tab:my_label}
% \end{table}

% \begin{table}[]
%     \centering

%     \begin{tabular}{p{5cm}|c|p{5cm}}
%         Name & Funktionale & Fehler \\
%         \hline\hline
%         RadauIIA3 & false & Error: DimensionMismatch: arguments must have the same number of rows \\
%         RadauIIA5 & false & Error: DimensionMismatch: arguments must have the same number of rows \\
%     \end{tabular}
%     \caption{Fully-Implicit Runge-Kutta Methods}
%     \label{tab:my_label}
% \end{table}

% \begin{table}[]
%     \centering

%     \begin{tabular}{p{5cm}|c|p{5cm}}
%         Name & Funktionale & Fehler \\
%         \hline\hline
%         PDIRK44 & false & Error: `@threads :static` cannot be used concurrently or nested \\
%     \end{tabular}
%     \caption{Parallel Diagonally Implicit Runge-Kutta Methods}
%     \label{tab:my_label}
% \end{table}

% \begin{table}[]
%     \centering

%     \begin{tabular}{p{5cm}|c|p{5cm}}
%         Name & Funktionale & Fehler \\
%         \hline\hline
%         ROS3P     & true & \\ 
%         Rodas3    & true & \\ 
%         RosShamp4 & true & \\ 
%         Veldd4    & true & \\ 
%         Velds4    & true & \\ 
%         GRK4T     & true & \\ 
%         GRK4A     & true & \\ 
%         Ros4LStab & true & \\ 
%         Rodas4    & true & \\ 
%         Rodas42   & true & \\ 
%         Rodas4P   & true & \\ 
%         Rodas4P2  & true & \\ 
%         Rodas5    & true & \\ 
%     \end{tabular}
%     \caption{Rosenbrock Methods}
%     \label{tab:my_label}
% \end{table}

% \begin{table}[]
%     \centering

%     \begin{tabular}{p{5cm}|c|p{5cm}}
%         Name & Funktionale & Fehler \\
%         \hline\hline
%         Rosenbrock23     & true & \\                                                                                                                          ║
%         Rosenbrock32     & true & \\                                                                                                                          ║
%         RosenbrockW6S4OS & true & \\                                                                                                                      ║
%         ROS34PW1a        & true & \\                                                                                                                             ║
%         ROS34PW1b        & true & \\                                                                                                                             ║
%         ROS34PW2         & true & \\                                                                                                                              ║
%         ROS34PW3         & true & \\            
%     \end{tabular}
%     \caption{Rosenbrock-W Methods}
%     \label{tab:my_label}
% \end{table}

% \begin{table}[]
%     \centering

%     \begin{tabular}{p{5cm}|c|p{5cm}}
%         Name & Funktionale & Fehler \\
%         \hline\hline
%             ImplicitEulerExtrapolation & true & \\ 
%             ImplicitDeuflhardExtrapolation & true & \\ 
%             ImplicitHairerWannerExtrapolation & true & \\ 
%     \end{tabular}
%     \caption{Parallelized Implicit Extrapolation Methods}
%     \label{tab:my_label}
% \end{table}

% \begin{table}[]
%     \centering

%     \begin{tabular}{p{5cm}|c|p{5cm}}
%         Name & Funktionale & Fehler \\
%         \hline\hline
%         PDIRK44 & false & Error: `@threads :static` cannot be used concurrently or nested \\     
%     \end{tabular}
%     \caption{Parallelized DIRK Methods}
%     \label{tab:my_label}
% \end{table}

% \begin{table}[]
%     \centering

%     \begin{tabular}{p{5cm}|c|p{5cm}}
%         Name & Funktionale & Fehler \\
%         \hline\hline
%         LawsonEuler  & false & Error: ArgumeError: Caching can only be used with SplitFunction \\
%         NorsettEuler & false & Error: ArgumeError: Caching can only be used with SplitFunction \\
%         ETD2         & false & Error: type ODEFunction has no field f1 \\
%         ETDRK2       & false & Error: ArgumeError: Caching can only be used with SplitFunction \\
%         ETDRK3       & false & Error: ArgumeError: Caching can only be used with SplitFunction \\
%         ETDRK4       & false & Error: ArgumeError: Caching can only be used with SplitFunction \\
%         HochOst4     & false & Error: ArgumeError: Caching can only be used with SplitFunction \\
%     \end{tabular}
%     \caption{Exponential Runge-Kutta Methods}
%     \label{tab:my_label}
% \end{table}

% \begin{table}[]
%     \centering

%     \begin{tabular}{p{5cm}|c|p{5cm}}
%         Name & Funktionale & Fehler \\
%         \hline\hline
%         Exp4      & false & Error: AssertiError: Dimension mismatch \\
%         EPIRK4s3A & false & Error: AssertiError: Dimension mismatch \\
%         EPIRK4s3B & false & Error: AssertiError: Dimension mismatch \\
%         EPIRK5P1  & false & Error: AssertiError: Dimension mismatch \\
%         EPIRK5P2  & false & Error: AssertiError: Dimension mismatch \\
%         EPIRK5s3  & false & Error: DimensionMismatch: tried to assign 2×1896 array to 3792×1 destination \\
%         EXPRB53s3 & false & Error: AssertiError: Dimension mismatch \\
%     \end{tabular}
%     \caption{Exponential Propagation Iterative Runge-Kutta Methods}
%     \label{tab:my_label}
% \end{table}

% \begin{table}[]
%     \centering

%     \begin{tabular}{p{5cm}|c|p{5cm}}
%         Name & Funktionale & Fehler \\
%         \hline\hline
%         Exprb32 & false & Error: DimensionMismatch: array could not be broadcast to match destination \\
%         Exprb43 & false & Error: DimensionMismatch: A has dimensions (3792,3792) but B has dimensions (2,1896) \\       
%     \end{tabular}
%     \caption{Adative Exponential Rosenbrock Methods}
%     \label{tab:my_label}
% \end{table}

% \begin{table}[]
%     \centering

%     \begin{tabular}{p{5cm}|c|p{5cm}}
%         Name & Funktionale & Fehler \\
%         \hline\hline
%         QNDF1 & true   & \\
%         QBDF1 & true   & \\
%         ABDF2 & true   & \\
%         QNDF2 & true   & \\
%         QBDF2 & true   & \\
%         QNDF  & false  & Erros DimensionMissmatch \\
%         QBDF  & false  & Erros DimensionMismatch \\
%         MEBDF2& false  & Works but slow \\
%         FBDF  & false  & Doesn work on gpu because scalar indexing \\
%     \end{tabular}
%     \caption{Mutlistep Methods}
%     \label{tab:my_label}
% \end{table}

% \begin{table}[]
%     \centering

%     \begin{tabular}{p{5cm}|c|p{5cm}}
%         Name & Funktionale & Fehler \\
%         \hline\hline
%         SSPSDIRK2 & false & Error: MethError: Cannot `convert` an object of type Float32 to an object of type CUDA.CuArray{Float32, 2, CUDA.Mem.DeviceBuffer}║ \\        
%     \end{tabular}
%     \caption{Implicit Strong-Stability Preserving Runge-Kutta Methods for Hyperbolic PDEs}
%     \label{tab:my_label}
% \end{table}

